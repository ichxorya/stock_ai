# stock_predictor_main.py
import logging
import streamlit as st
import yfinance as yf
from datetime import datetime, timedelta
from models.lstm_model import run_lstm
from models.xgboost_model import run_xgboost
from models.random_forest_model import run_random_forest
from models.arima_model import run_arima
from models.svr_model import run_svr
from models.gbm_model import run_gbm
from models.knn_model import run_knn
import pandas as pd
import numpy as np

# Set up logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# Weight configurations for combining model predictions
WEIGHT_CONFIGURATIONS = {
    "Default": {
        'LSTM': 0.3,
        'XGBoost': 0.15,
        'Random Forest': 0.15,
        'ARIMA': 0.1,
        'SVR': 0.1,
        'GBM': 0.1,
        'KNN': 0.1
    },
    "Trend-Focused": {
        'LSTM': 0.35,
        'XGBoost': 0.2,
        'Random Forest': 0.15,
        'ARIMA': 0.1,
        'SVR': 0.08,
        'GBM': 0.07,
        'KNN': 0.05
    }
}

@st.cache_data(ttl=3600)
def fetch_stock_data(symbol, days):
    """
    Fetch historical stock data using Yahoo Finance.

    Args:
        symbol (str): The stock symbol to fetch data for.
        days (int): The number of historical days to fetch data for.

    Returns:
        pd.DataFrame: DataFrame containing stock data with columns ['Close', 'High', 'Low', 'Volume'].
    """
    end_date = datetime.now()
    start_date = end_date - timedelta(days=days)
    df = yf.download(symbol, start=start_date, end=end_date)
    if df.empty:
        logging.warning("No data fetched for the symbol. Please check the symbol or date range.")
        return None
    return df[['Close', 'High', 'Low', 'Volume']].dropna()

def calculate_rsi(series, window=14):
    delta = series.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

def calculate_macd(series):
    ema12 = series.ewm(span=12, adjust=False).mean()
    ema26 = series.ewm(span=26, adjust=False).mean()
    return ema12 - ema26

def calculate_atr(df, window=14):
    high_low = df['High'] - df['Low']
    high_close = np.abs(df['High'] - df['Close'].shift())
    low_close = np.abs(df['Low'] - df['Close'].shift())
    ranges = pd.concat([high_low, high_close, low_close], axis=1)
    true_range = ranges.max(axis=1)
    return true_range.rolling(window).mean()

def calculate_bollinger_bands(series, window=20, num_std=2):
    rolling_mean = series.rolling(window=window).mean()
    rolling_std = series.rolling(window=window).std()
    upper_band = rolling_mean + (rolling_std * num_std)
    lower_band = rolling_mean - (rolling_std * num_std)
    return upper_band, lower_band

def calculate_stochastic(df, window=14):
    low_min = df['Low'].rolling(window=window).min()
    high_max = df['High'].rolling(window=window).max()
    return ((df['Close'] - low_min) / (high_max - low_min)) * 100

def calculate_williams_r(df, window=14):
    low_min = df['Low'].rolling(window=window).min()
    high_max = df['High'].rolling(window=window).max()
    return ((high_max - df['Close']) / (high_max - low_min)) * -100

def calculate_technical_indicators(df):
    """
    Calculate technical indicators for the stock data.

    Args:
        df (pd.DataFrame): DataFrame containing stock data.

    Returns:
        pd.DataFrame: DataFrame with additional columns for technical indicators.
    """
    df['MA5'] = df['Close'].rolling(window=5).mean()
    df['MA20'] = df['Close'].rolling(window=20).mean()
    df['MA50'] = df['Close'].rolling(window=50).mean()
    df['MA200'] = df['Close'].rolling(window=200).mean()
    df['RSI'] = calculate_rsi(df['Close'])
    df['MACD'] = calculate_macd(df['Close'])
    df['ROC'] = df['Close'].pct_change(periods=10) * 100
    df['ATR'] = calculate_atr(df)
    df['BB_upper'], df['BB_lower'] = calculate_bollinger_bands(df['Close'])
    df['Volume_MA'] = df['Volume'].rolling(window=20).mean()
    df['Volume_Rate'] = df['Volume'] / df['Volume'].rolling(window=20).mean()
    df['EMA12'] = df['Close'].ewm(span=12, adjust=False).mean()
    df['EMA26'] = df['Close'].ewm(span=26, adjust=False).mean()
    df['MOM'] = df['Close'].diff(10)
    df['STOCH_K'] = calculate_stochastic(df)
    df['WILLR'] = calculate_williams_r(df)
    return df.dropna()

def main():
    """
    Main function for the Streamlit application.
    """
    st.title("Stock Predictor with Weighted Models")
    st.write("Predict stock prices using multiple models and technical indicators.")

    # User input for stock symbol and historical days
    stock_symbol = st.text_input("Enter Stock Symbol (default: AAPL):", value="AAPL")
    days = st.slider("Select number of historical days", 30, 3650, 180)
    weight_config = st.selectbox("Select Weight Configuration", WEIGHT_CONFIGURATIONS.keys())

    # Run predictions when button is clicked
    if st.button("Run Predictions"):
        st.write(f"Fetching data for `{stock_symbol}` over the last `{days}` days...")
        data = fetch_stock_data(stock_symbol, days)
        if data is None or data.empty:
            st.error("No data available for the entered stock symbol. Please try again.")
            return

        # Add technical indicators
        st.write("Adding technical indicators...")
        data = calculate_technical_indicators(data)
        if data.empty:
            st.error("No data available after adding technical indicators. Please try another stock or time period.")
            return

        st.write(data.head())

        # Run predictions for each model
        results = []
        weighted_sum = 0
        total_weight = sum(WEIGHT_CONFIGURATIONS[weight_config].values())

        for model_name, model_function in {
            "LSTM": run_lstm,
            "XGBoost": run_xgboost,
            "Random Forest": run_random_forest,
            "ARIMA": run_arima,
            "SVR": run_svr,
            "GBM": run_gbm,
            "KNN": run_knn,
        }.items():
            st.write(f"Running `{model_name}` model...")
            try:
                if data.empty:
                    raise ValueError("Insufficient data for training.")
                predicted_price = model_function(data)
                weight = WEIGHT_CONFIGURATIONS[weight_config][model_name]
                weighted_sum += predicted_price * weight
                results.append({"Model": model_name, "Predicted Price": predicted_price, "Weight": weight})
            except Exception as e:
                logging.error(f"Error in {model_name}: {e}")
                results.append({"Model": model_name, "Predicted Price": "Error", "Weight": 0})

        # Calculate weighted average price
        final_price = weighted_sum / total_weight if total_weight > 0 else 0
        st.subheader("Prediction Results")
        st.write(pd.DataFrame(results))
        st.write(f"Weighted Average Predicted Price: {final_price:.2f}")

if __name__ == "__main__":
    main()
